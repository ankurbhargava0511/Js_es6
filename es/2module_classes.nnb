{
    "cells": [
        {
            "language": "typescript",
            "source": [
                "//Module is excutes by loading the modules\r\n//Module is only excutes once at initial load\r\n//Simply by loading a module ES6 pot code in strict mode\r\n\r\n\r\n\r\n\r\n//99\r\nimport {projectId}  from 'module1.js';\r\nconsole.log(projectId);\r\n////File base.js:\r\nexport  let  projectId=99;\r\n////File module1.js:\r\n\r\n\r\n//BuildIt has id: 99\r\n////File base.js:\r\nimport {projectId,projectName} from 'module1.js';\r\nconsole.log(`${projectName}hasid:${projectId}`);\r\n\r\n////File module1.js:\r\nexport  let  projectId=99;\r\nexport  let  projectName='BuildIt';\r\n// Alias name\r\n//BuildIt has id: 99\r\n////File base.js:\r\nimport {projectId as id,projectName} from 'module1.js';\r\nconsole.log(`${projectName}hasid:${id}`);\r\n\r\n////File module1.js:\r\nexport  let  projectId=99;\r\nexport  let  projectName='BuildIt';\r\n\r\n/*\r\nRuntime error:\r\nprojectId is undefined\r\n//File base.js:\r\n*/\r\nimport {projectIdasid,projectName} from 'module1.js';\r\nconsole.log(`${projectName}hasid:${projectId}`);\r\n\r\n////File module1.js:\r\nexport  let  projectId=99;\r\nexport  let  projectName='BuildIt';\r\n\r\n//in module1\r\n//starting in base\r\n//ending in base\r\n////File base.js:\r\nconsole.log('startinginbase');\r\nimport {projectId} from 'module1.js';\r\nconsole.log('endinginbase');\r\n\r\n////File module1.js:\r\nexport  let  projectId=99;\r\nconsole.log('inmodule1');\r\n\r\n//default\r\n//BuildIt\r\n////File base.js:\r\nimport  someValue  from 'module1.js';\r\nconsole.log(someValue);\r\n\r\n////File module1.js:\r\nexport  let  projectId=99;\r\nlet  projectName='BuildIt';\r\nexport  default projectName;\r\n\r\n\r\n//\r\n//BuildIt\r\n////File base.js:\r\nimport {default as myProjectName} from 'module1.js';\r\nconsole.log(myProjectName);\r\n\r\n////File module1.js:\r\nexport  let  projectId=99;\r\nlet  projectName='BuildIt';\r\nexport  default projectName;\r\n\r\n//undefined // as no default\r\n////File base.js:\r\nimport someValue from 'module1.js';\r\nconsole.log(someValue);\r\n\r\n//File module1.js:\r\nlet projectId=99;\r\nlet projectName='BuildIt';\r\nexport {projectId,projectName};\r\n\r\n//99\r\n//File base.js:\r\nimport someValue from 'module1.js';\r\nconsole.log(someValue);\r\n\r\n//File module1.js:\r\nlet projectId=99;\r\nlet projectName='BuildIt';\r\nexport {projectId as default,projectName};\r\n/*\r\n{ projectId: 99,\r\nprojectName: 'BuildIt'}*/\r\n//File base.js:\r\nimport * as values from 'module1.js';\r\nconsole.log(values);\r\n\r\n//File module1.js:\r\nlet projectId=99;\r\nlet projectName='BuildIt';\r\nexport {projectId,projectName};\r\n\r\n//Named Exports in Modules\r\n\r\n//Runtime error: projectId is read-only\r\n//File base.js:\r\nimport { projectId} from 'module1.js';\r\nprojectId=8000;\r\nconsole.log(projectId);\r\n\r\n//File module1.js:\r\nexport let projectId=99;\r\n\r\n//8000\r\n//File base.js:\r\nimport {project} from 'module1.js';\r\nproject.projectId=8000;\r\nconsole.log(project.projectId);\r\n\r\n//File module1.js: // named\r\nexport let project={projectId:99};\r\n\r\n//8000\r\n//8000\r\n//File base.js:\r\nimport {project,showProject} from 'module1.js';\r\nproject.projectId=8000;\r\nshowProject();\r\nconsole.log(project.projectId);\r\n\r\n//File module1.js:\r\nexport let project={ projectId:99};\r\nexport function showProject(){\r\n\tconsole.log(project.projectId);\r\n};\r\n// exporting functions\r\n//in original\r\n//in updated\r\n//File base.js:\r\nimport {showProject,updateFunction} from 'module1.js';\r\nshowProject();\r\nupdateFunction();\r\nshowProject();\r\n\r\n//File module1.js:\r\nexport function showProject(){\r\n\tconsole.log('inoriginal');\r\n}\r\nexport function updateFunction(){\r\n\tshowProject=function(){\r\n\t\tconsole.log('inupdated');\r\n};\r\n};\r\n\r\n//Class Fundamentals\r\n//function\r\nclass Task{\r\n}\r\nconsole.log(typeof(Task));\r\n\r\n//object\r\nclass Task{}\r\nlet task=newTask();\r\nconsole.log(typeof(task));\r\n\r\n\r\n//true\r\nclass Task{}\r\nlet task=newTask();\r\nconsole.log(task instanceof Task);\r\n\r\n//99\r\nclass Task{showId(){\r\n\tconsole.log('99');\r\n}}\r\nlet task=newTask();\r\ntask.showId();\r\n\r\n//true\r\nclass Task{showId(){\r\n\tconsole.log('99');\r\n}}\r\nlet task=newTask();\r\nconsole.log(task.showId===Task.prototype.showId);\r\n\r\n//constructing Task\r\nclass Task{\r\n\tconstructor(){\r\n\t\tconsole.log('constructingTask');\r\n\t}\r\n\tshowId(){\r\n\t\tconsole.log('99');\r\n\t\t}\r\n\t}\r\nlet task=newTask();\r\n\r\n\r\n\r\n//Syntax error : because of ,\r\nclass Task{\r\n\tconstructor(){\r\n\t\tconsole.log('constructingTask');\r\n},\r\nshowId(){\r\n\tconsole.log('99');\r\n}}\r\nlet task=newTask();\r\n\r\n//Syntax error\r\n/*\r\nclass Task{\r\n\tlet taskId=9000;\r\n\tconstructor(){\r\n\t\tconsole.log('constructingTask');\r\n\t\t}\r\n\tshowId(){\r\n\t\tconsole.log('99');\r\n\t\t}\r\n\t}\r\nlet task=newTask();\r\n*/\r\n//Error: Use before declaration\r\nlet task=newTask();\r\nclass Task{\r\n\tconstructor(){\r\n\t\tconsole.log('constructingTask');\r\n}}\r\n\r\n//constructing Task // we can create class and assign it to variables as expressions\r\nlet newClass=class Task{\r\n\tconstructor(){\r\n\t\tconsole.log('constructingTask');\r\n}};\r\nnew newClass();\r\n\r\n//constructing Task\r\nlet Task=function(){\r\n\tconsole.log('constructingTask');\r\n};\r\nlet task={};\r\nTask.call(task);\r\n\r\n//Error: class  constructor cannot be called with the new keyword\r\n// class vs functions-- call contructor cannot be call with new keyword  \r\nclass Task{\r\n\tconstructor(){\r\n\t\tconsole.log('constructingTask');\r\n}};\r\nlet task={};\r\nTask.call(task);\r\n\r\n//true // function goes to global namespace\r\nfunction Project(){};\r\nconsole.log(window.Project===Project);\r\n\r\n//false // it does not polute global object\r\nclass Task{}\r\nconsole.log(window.Task===Task);\r\n\r\n// extends  and super\r\n\r\n//constructing Project\r\nclass Project{\r\n\tconstructor(){\r\n\t\tconsole.log('constructing Project');\r\n}}\r\nclass SoftwareProject  extends  Project{}\r\nlet p=new SoftwareProject();\r\n\r\n\r\n\r\n//constructing Project: Mazatlan\r\nclass Project{\r\n\tconstructor(name){\r\n\t\tconsole.log('constructingProject:'+name);\r\n}}\r\nclass SoftwareProject  extends Project{}\r\nlet p=new SoftwareProject('Mazatlan');\r\n\r\n//constructing Project\r\n//constructing SoftwareProject\r\nclass Project{\r\n\tconstructor(){\r\n\t\tconsole.log('constructingProject');\r\n}}\r\nclass SoftwareProject extends Project{\r\n\tconstructor(){\r\n\t\tsuper();\r\n\tconsole.log('constructingSoftwareProject');\r\n}}\r\nlet p=new SoftwareProject();\r\n\r\n//ReferenceError: this is not defined\r\n// if class is using extends and constructure it should use super\r\nclass Project{\r\n\tconstructor(){\r\n\t\tconsole.log('constructingProject');\r\n}}\r\nclass SoftwareProject extends Project{\r\n\tconstructor(){//super();\r\n    console.log('constructing Software Project');\r\n}}\r\nlet p=new SoftwareProject();\r\n\r\n//ReferenceError: this is not defined\r\nclass Project{\r\n\t//constructor(){\r\n\t\t//console.log('constructingProject');\r\n//}\r\n}\r\nclass SoftwareProject extends Project{constructor(){\r\n\t//super();\r\nconsole.log('constructingSoftwareProject');\r\n}}\r\nlet p=new SoftwareProject();\r\n\r\n//constructing Project\r\n//constructing SoftwareProject\r\nclass Project{\r\n\tconstructor(){\r\n\t\tconsole.log('constructingProject');\r\n}}\r\nclass SoftwareProject extends Project{\r\n\tconstructor(){super();\r\nconsole.log('constructingSoftwareProject');\r\n}}\r\nlet p=new SoftwareProject();\r\n\r\n// Methods \r\n//50\r\nclass Project{\r\n\tgetTaskCount(){\r\n\treturn50;\r\n}}\r\nclass SoftwareProject extends Project{}\r\nlet p=new SoftwareProject();\r\nconsole.log(p.getTaskCount());\r\n\r\n//66 overriding prototype \r\nclass Project{\r\n\tgetTaskCount(){\r\n\t\treturn50;\r\n}}\r\nclass SoftwareProject extends Project{getTaskCount(){return66;\r\n}}\r\nlet p=new SoftwareProject();\r\nconsole.log(p.getTaskCount());\r\n\r\n//56 using super in Method\r\nclass Project{\r\n\tgetTaskCount(){\r\n\treturn50;\r\n}}\r\nclass SoftwareProject extends Project{\r\n\tgetTaskCount(){\r\n\t\treturn super.getTaskCount()+6;\r\n}}\r\nlet p=new SoftwareProject();\r\nconsole.log(p.getTaskCount());\r\n\r\n//57 using super with object literals\r\nlet project={\r\n\tgetTaskCount(){\r\n\t\treturn50;\r\n}};\r\nlet softwareProject={\r\n\tgetTaskCount(){\r\n\t\treturn super.getTaskCount()+7;\r\n}}\r\n// linking object literals as proptotypes\r\nObject.setPrototypeOf(softwareProject,project);\r\nconsole.log(softwareProject.getTaskCount());\r\n\r\n//Properties for Class Instances\r\n\r\n//Mazatlan\r\nclass Project{\r\n\tconstructor(){\r\n\t\tthis.location='Mazatlan';\r\n}}\r\nclass SoftwareProject extends Project{\r\n\tconstructor(){super();\r\n}}\r\nlet p=new SoftwareProject();\r\nconsole.log(p.location);\r\n\r\n//undefined \r\n//because we are using let for this \r\n// instance properties\r\n// let const does not attached to an instance\r\nclass Project{\r\n\tconstructor(){\r\n\t\tlet  location='Mazatlan';\r\n}}\r\nclass SoftwareProject extends Project{\r\n\tconstructor(){super();\r\n}}\r\nlet p=new SoftwareProject();\r\nconsole.log(p.location);\r\n\r\n//Mazatlan Beach\r\nclass Project{\r\n\tconstructor(){\r\n\t\tthis.location='Mazatlan';\r\n}}\r\nclass SoftwareProject extends Project{\r\n\tconstructor(){\r\n\t\tsuper();\r\n\t\tthis.location=this.location+'Beach';\r\n}}\r\nlet p=new SoftwareProject();\r\nconsole.log(p.location);\r\n\r\n//Static Members\r\n//0\r\nclass Project{\r\n\tstatic getDefaultId(){\r\n\t\treturn 0;\r\n}}\r\nconsole.log(Project.getDefaultId());\r\n\r\n//Error: Object doesn't support property or method getDefaultId\r\n// because its static not instance\r\nclass Project{\r\n\tstatic getDefaultId(){\r\n\t\treturn 0;\r\n}}\r\nvar p=newProject();\r\nconsole.log(p.getDefaultId());\r\n\r\n//Syntax Error: ( expected\r\nclass Project{\r\n\tstatic let id=0;\r\n}\r\nconsole.log(Project.id);\r\n\r\n//99  below is low we can attached static property to class\r\nclass Project{}\r\nProject.id=99;\r\nconsole.log(Project.id);\r\n\r\n//new.target\r\n// it is use in contructir function\r\nclass Project{\r\n\tconstructor(){\r\n\t\tconsole.log(typeof new.target);\r\n}}\r\nvar p=newProject();\r\n\r\n\r\n/*\r\nconstructor() { \r\n\tconsole.log(new.target);\r\n }*/\r\nclass Project{\r\n\tconstructor(){console.log(new.target);\r\n}}\r\nvar p=newProject();\r\n\r\n/*\r\nconstructor() {\r\nsuper();\r\n}*/\r\n\r\n// so this means new.target always point to initial contructor called\r\nclass Project{\r\n\tconstructor(){\r\n\t\tconsole.log(new.target);\r\n}}\r\nclass SoftwareProject extends Project{\r\n\tconstructor(){\r\n\t\tsuper();\r\n}}\r\nvar p=new SoftwareProject();\r\n\r\n/*constructor(...args) {\r\nsuper(...args);\r\n\r\n}*/\r\n//As we dont have constructure it shows default contructor \r\nclass Project{\r\n\tconstructor(){\r\n\t\tconsole.log(new.target);\r\n}}\r\nclass SoftwareProject extends Project{}\r\nvar p=new SoftwareProject();\r\n\r\n//99\r\nclass Project{\r\n\tconstructor(){\r\n\t\tconsole.log(new.target.getDefaultId());\r\n}}\r\nclass SoftwareProject extends Project{\r\n\tstatic getDefaultId(){\r\n\t\treturn99;\r\n}}\r\nvar p=new SoftwareProject();\r\n"
            ],
            "outputs": []
        }
    ]
}